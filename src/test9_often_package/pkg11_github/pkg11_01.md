好的，我帮你整理一份 **Go 的 `samber/lo` 与 Java Stream / Guava 方法的对应关系表**，方便你从 Java 思维迁移到 Go。

注意：Go 没有完全一模一样的概念，有些是 `Stream`、有些是 Guava 工具类的组合。

---

## 1️⃣ 映射 / 遍历 / 筛选

| Java Stream / Guava   | 功能   | `samber/lo` 对应                                                        | 备注                 |
| --------------------- | ---- | --------------------------------------------------------------------- | ------------------ |
| `stream().map(f)`     | 元素映射 | `lo.Map(slice, func(item, idx) T) []T`                                | 返回新 slice          |
| `stream().filter(f)`  | 元素筛选 | `lo.Filter(slice, func(item, idx) bool) []T`                          | 返回满足条件的新 slice     |
| `stream().forEach(f)` | 遍历   | `for _, v := range slice {}` 或 `lo.ForEach(slice, func(item, idx){})` | `lo.ForEach` 只做副作用 |

---

## 2️⃣ 聚合 / 统计

| Java Stream       | 功能    | `samber/lo` 对应                              | 备注            |
| ----------------- | ----- | ------------------------------------------- | ------------- |
| `sum()`           | 求和    | `lo.Sum(slice)`                             | slice 必须是数字类型 |
| `max()` / `min()` | 最大/最小 | `lo.Max(slice)` / `lo.Min(slice)`           | 适用于数字或可比较类型   |
| `count()`         | 元素数量  | `len(slice)` 或 `lo.Count(slice, predicate)` | predicate 可选  |
| `average()`       | 平均值   | `lo.Average(slice)`                         | 只适合数字类型       |

---

## 3️⃣ 搜索 / 查找

| Java Stream / List | 功能        | `samber/lo` 对应                                   |
| ------------------ | --------- | ------------------------------------------------ |
| `findFirst()`      | 找到第一个满足条件 | `lo.Find(slice, func(item, idx) bool) (T, bool)` |
| `anyMatch()`       | 是否存在满足条件  | `lo.Some(slice, func(item, idx) bool) bool`      |
| `allMatch()`       | 全部满足条件    | `lo.Every(slice, func(item, idx) bool) bool`     |
| `noneMatch()`      | 全部不满足     | `lo.None(slice, func(item, idx) bool) bool`      |
| `contains()`       | 包含元素      | `lo.Contains(slice, item)`                       |

---

## 4️⃣ 转换 / 收集

| Java Stream / Guava              | 功能       | `samber/lo` 对应                                 |
| -------------------------------- | -------- | ---------------------------------------------- |
| `collect(Collectors.toList())`   | 收集为 List | `lo.Map(...)` / `lo.Filter(...)` 返回 slice      |
| `collect(Collectors.toMap(...))` | 收集为 Map  | `lo.KeyBy(slice, func(item) key) map[key]item` |
| `Collectors.toSet()`             | 去重集合     | `lo.Uniq(slice)`                               |
| `Lists.partition(list, n)`       | 切片成块     | `lo.Chunk(slice, n)`                           |

---

## 5️⃣ 扁平化 / 合并

| Java Stream | 功能    | `samber/lo` 对应                          |
| ----------- | ----- | --------------------------------------- |
| `flatMap()` | 扁平化映射 | `lo.FlatMap(slice, func(item) []T) []T` |

---

## 6️⃣ 排序

| Java Stream / List   | 功能    | `samber/lo` 对应                       |
| -------------------- | ----- | ------------------------------------ |
| `sorted()`           | 升序    | `lo.Sort(slice, func(a,b T) bool)`   |
| `sorted(Comparator)` | 自定义排序 | `lo.SortBy(slice, func(a,b T) bool)` |

---

## 7️⃣ 组合 / 集合操作

| Java / Guava                | 功能  | `samber/lo` 对应         |
| --------------------------- | --- | ---------------------- |
| `Sets.intersection(a,b)`    | 交集  | `lo.Intersect(a,b)`    |
| `Sets.difference(a,b)`      | 差集  | `lo.Difference(a,b)`   |
| `Lists.indexOf(list, x)`    | 查索引 | `lo.IndexOf(slice, x)` |
| `List.subList(from,to)`     | 分片  | `slice[from:to]`（原生）   |
| `Collections.reverse(list)` | 反转  | `lo.Reverse(slice)`    |

---

## 8️⃣ Optional / Result

| Java Optional      | 功能   | `samber/mo` 对应                         |
| ------------------ | ---- | -------------------------------------- |
| `Optional.of(...)` | 包装值  | `mo.Some(val)`                         |
| `Optional.empty()` | 空    | `mo.None[T]()`                         |
| `isPresent()`      | 是否存在 | `Some.IsPresent()`                     |
| `orElse()`         | 默认值  | `Some.OrElse(default)`                 |
| `map()`            | 转换值  | `Some.Map(func(val T) R) mo.Option[R]` |

---

### ✅ 总结

* `samber/lo` = **Java Stream API + Guava Collection 工具类**
* `samber/mo` = **Java Optional / Result**
* 功能覆盖：Map/Filter/Reduce/Sum/Max/Min/Find/KeyBy/Uniq/Chunk/Intersect 等
* 差异：Go 没有懒加载流（Stream 本质是惰性求值），`lo` 是立即计算（类似 `collect` 的结果）。

---

如果你愿意，我可以帮你画一张 **可打印对照表 PDF**，把 **Java Stream/Guava 方法 ↔ lo/mo 对应函数** 全部列出来，方便随手查。

你想让我画吗？
