# 内存淘汰算法
内存淘汰算法（也叫缓存替换算法）是为了在缓存空间有限时，决定哪些数据被删除以给新数据腾出空间。不同算法策略不同，适用场景也不同。下面我整理一个完整清单和分析：

---

## 1️⃣ 按访问时间的淘汰策略

### 1. LRU（Least Recently Used，最近最少使用）

* **核心思想**：最近最少使用的数据最可能不再被访问，所以优先淘汰。
* **优点**：符合“热点数据”原则。
* **缺点**：需要维护访问顺序，开销略大。
* **常用场景**：Redis、操作系统页面缓存。

### 2. LFU（Least Frequently Used，最不常用）

* **核心思想**：使用次数最少的数据被淘汰。
* **优点**：能够保留高访问频率的热点数据。
* **缺点**：频率统计可能导致“老旧热点”被误保留。
* **常用场景**：数据库缓存、对象缓存。

### 3. FIFO（First In First Out，先进先出）

* **核心思想**：最先进入缓存的数据先淘汰。
* **优点**：实现简单，不需要复杂的数据结构。
* **缺点**：不考虑访问频率或时间，容易误删热点数据。
* **常用场景**：简单队列缓存。

---

## 2️⃣ 按过期时间/生存期策略

### 1. TTL（Time To Live，存活时间）

* **核心思想**：缓存每条数据带一个过期时间，到期自动淘汰。
* **优点**：实现简单，防止缓存无限增长。
* **缺点**：不考虑访问频率或时间，可能提前删除热点数据。
* **常用场景**：HTTP 缓存、Redis TTL。

### 2. TTI（Time To Idle，空闲时间淘汰）

* **核心思想**：数据在一定时间内未被访问，则淘汰。
* **优点**：热点数据如果持续访问不会被删除。
* **缺点**：需要记录最后访问时间。
* **常用场景**：缓存中间件，如 Ehcache。

---

## 3️⃣ 综合策略

### 1. LRU-K

* **核心思想**：考虑最近 K 次访问时间，淘汰最久未被访问的。
* **优点**：比普通 LRU 更加平滑，防止“突发访问”污染缓存。
* **缺点**：实现复杂。

### 2. LFU + LRU（如 Redis LFU）

* **核心思想**：结合访问频率和最近使用时间，淘汰低频且老旧数据。
* **优点**：兼顾热点数据和时间局部性。
* **缺点**：实现较复杂，需要额外统计。

---

## 4️⃣ 随机策略

### 1. Random

* **核心思想**：随机选择缓存数据淘汰。
* **优点**：实现非常简单。
* **缺点**：可能误删热点数据。
* **常用场景**：对性能要求低、简单缓存系统。

---

## 5️⃣ 其他算法/优化

| 算法                              | 特点                          | 场景          |
| ------------------------------- | --------------------------- | ----------- |
| ARC（Adaptive Replacement Cache） | 动态在 LRU 和 LFU 之间切换          | 高性能数据库缓存    |
| CLOCK                           | LRU的近似实现，降低开销               | 操作系统页面淘汰    |
| 2Q                              | 使用两个队列，一个 LRU 队列和一个 FIFO 队列 | 平衡频繁访问和临时访问 |

---

### 🔹 总结

* **热点数据优先保留**：LRU、LFU、LRU-K、LFU+LRU、ARC
* **简单淘汰**：FIFO、Random
* **基于时间**：TTL、TTI
* **操作系统优化**：CLOCK、2Q

---

如果你希望，我可以帮你画一个 **内存淘汰算法分类图**，把算法按“访问时间、访问频率、时间/过期、随机”清晰分类，便于快速理解。

你希望我画吗？
