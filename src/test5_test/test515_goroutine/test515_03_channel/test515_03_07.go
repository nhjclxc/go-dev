package main

// 14.2.7 信号量模式
// 14.2.8 实现并行的 for 循环
func main7() {

	// 在 for 循环中并行计算迭代可能带来很好的性能提升。不过所有的迭代都必须是独立完成的。
	//有些语言比如 Fortress 或者其他并行框架以不同的结构实现了这种方式，在 Go 中用协程实现起来非常容易：

	// 14.2.8 实现并行的 for 循环
	data := []interface{}{}
	for i, v := range data {
		go func(i1 int, v1 interface{}) {
			//doSomething(i1, v1)
			//...
		}(i, v)
		// 注意上述代码中闭合函数的用法：i、v 都是作为参数传入闭合函数的，这一做法使得每个协程（译者注：在其启动时）获得一份 i 和 v 的单独拷贝，
		//从而向闭合函数内部屏蔽了外层循环中的 i 和 v 变量；否则，for 循环的下一次迭代会更新所有协程中 i 和 v 的值。
		//另一方面，切片 res 没有传入闭合函数，因为协程不需要 res 的单独拷贝。切片 res 也在闭合函数中但并不是参数。
		// 也就是为了防止一开始调用协程时的i和v，在下一轮主协程中改变i和v的值，通过在当前调用子协程的时候传入，这样就避免了在子协程中i和v的改变

	}

}
