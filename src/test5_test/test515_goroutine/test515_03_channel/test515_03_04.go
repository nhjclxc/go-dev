package main

import "fmt"

// 14.2.4 通过一个（或多个）通道交换数据进行协程同步。
func main4() {
	/*
	   	通信是一种同步形式：通过通道，两个协程在通信（协程会合）中某刻同步交换数据。无缓冲通道成为了多个协程同步的完美工具。

	      甚至可以在通道两端互相阻塞对方，形成了叫做死锁的状态。Go 运行时会检查并 panic()，停止程序。死锁几乎完全是由糟糕的设计导致的。

	      无缓冲通道会被阻塞。设计无阻塞的程序可以避免这种情况，或者使用带缓冲的通道。
	*/

	out := make(chan int)
	// 先发送
	out <- 2
	// 再去开启一个子协程接收，经过断点发现：断点没有经过：go f1(out)，
	//由此可得出结论，在主协程发送完数据2之后就立马进入等待消费状态，而消费协程在发送之后才被执行，消费协程还没来得及开启
	// 因此，代码会一直卡在 out <- 2这里，去等待out通道里面的2被消费
	go f1(out)

	/*
		👇 执行顺序详解：
			程序进入 main()，执行 out := make(chan int)，创建了一个无缓冲的 channel。
			然后执行 out <- 2，这是一个发送操作，因为是无缓冲 channel，所以它必须等待另一个 goroutine 读取它才能继续。
			但 go f1(out) 是在发送之后调用的，所以它还没有启动，f1 中的 <-in 也就还没开始执行。
			所以，主 goroutine 在第 3 行阻塞了，卡在了 out <- 2 上。
			子 goroutine 没有机会被调度运行，永远无法执行 f1(out)。
			最终 Go 运行时检测到所有 goroutine 都处于等待状态，无法前进，抛出 fatal error: all goroutines are asleep - deadlock!
	*/

	// 经过上面的分析，我没得出一个重要的结论，
	// 		如果是主协程发送数据，子协程接收数据的话，必须先开启子协程去接收，如何在主协程里面才能去发送
	//		如果发送与接收都是子协程的话，发送协程和接收协程的开启顺序无强制要求，但是此时，必须保证主协程还可用的状态，否则整个程序会退出

}

func f1(in chan int) {
	fmt.Println(<-in)
}
