worker_processes 1;


# # ginx 以 后台守护进程（daemon）方式启动。
# daemon on;

# 默认是 error 级别的
# error_log logs/error.log info;
# error_log logs/error.log wran;
error_log /usr/local/openresty/nginx/logs/error.log info;
# access_log /usr/local/openresty/nginx/logs/access.log;
pid /var/run/nginx.pid;

events {
    worker_connections  256;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    # Lua 配置
    lua_package_path "/usr/local/openresty/nginx/lua/?.lua;/usr/local/openresty/nginx/lua/?/init.lua;;";
    # lua_package_path "/usr/local/openresty/nginx/lua/?.lua;;";

    # 共享内存（限流用）
    lua_shared_dict rate_limit 10m;
    lua_shared_dict my_dict 10m;

    # OpenResty 是否开启 Lua 代码缓存的开关
    # 主要用于 开发环境（关闭 off） 和 生产环境（开启 on）
    # 每次修改外部lua文件就不需要重启nginx了
    lua_code_cache off;

    # 初始化
    # init_by_lua_block {
        # require "resty.core"
    # }

    ## --------------------------------------------------------
    ## init_worker_by_lua_block：每个 worker 进程启动后执行
    ## --------------------------------------------------------
    init_worker_by_lua_block {
        local dict = ngx.shared.rate_limit
        local cjson = require "cjson.safe"
        dict:set("config", cjson.encode({ x = 1 }))
    }

    server {
        listen 8090;


        # 动态路由
        # include $prefix/conf/conf.d/*.conf;  # 使用openresty原生启动
        include /usr/local/openresty/nginx/conf/conf.d/*.conf; # 使用docker启动


        # nginx api for lua : https://github.com/openresty/lua-nginx-module?tab=readme-ov-file#nginx-api-for-lua

        
        location /ctx {
            # https://github.com/openresty/lua-nginx-module?tab=readme-ov-file#ngxctx
            # ctx可以在同一个请求的多个lua块中进行传递
            # 该ngx.ctx.foo条目在请求的重写、访问和内容阶段始终存在。
            # 每一个请求都有一个自己的请求表副本，类似go中gin里面的ctx上下文
            # 注意：一个location下面不能重复写同一个lua块，如不能出现两个content_by_lua_block{}

            rewrite_by_lua_block {
                ngx.ctx.foo = 666
            }
            access_by_lua_block {
                ngx.ctx.foo = ngx.ctx.foo + 99
            }
            content_by_lua_block {
                local ngx = require "ngx"

                ngx.say("ngx.ctx.foo = ", ngx.ctx.foo)
                ngx.ctx.foo = ngx.ctx.foo + 9
                ngx.say("ngx.ctx.foo2 = ", ngx.ctx.foo)
            }
        }

        location /ctx-main {
            content_by_lua_block {
                ngx.ctx.myval = 666
                ngx.say("main ngx.ctx.myval1 = ", ngx.ctx.myval)
                ngx.ctx.myval = ngx.ctx.myval + 9
                -- 将请求传递到 /ctx-sub 里面看看myval数据是否会变
                local res = ngx.location.capture("/ctx-sub")
                ngx.print(res.body) -- 将ctx-sub到响应输出
                ngx.say("main ngx.ctx.myval2 = ", ngx.ctx.myval)

                -- ngx.ctx.tab1 = { foo = 32, bar = 54 }

                -- ngx.say("ctx.tab1 = ", ngx.ctx.tab1)
                -- local cjson = require "cjson.safe"
                -- ngx.ctx.tab1 = { foo = 32, bar = 54 }
                -- ngx.say("ctx.tab1 = ", cjson.encode(ngx.ctx.tab1))

            }
        }

        location /ctx-sub {
            content_by_lua_block {
                ngx.say("sub ngx.ctx.myval1 = ", ngx.ctx.myval)
                ngx.ctx.myval = 8
                ngx.say("sub ngx.ctx.myval2 = ", ngx.ctx.myval)
                ngx.ctx.myval = ngx.ctx.myval + 9
                ngx.say("sub ngx.ctx.myval3 = ", ngx.ctx.myval)
            }
        }

        location /lc {
            # https://github.com/openresty/lua-nginx-module?tab=readme-ov-file#ngxlocationcapture
            # ngx.location.capture可以在nginx到location之间跳转，发出同步但非阻塞的子请求
            # res = ngx.location.capture(uri, options?)

            content_by_lua_block {

            }
        }
        location /lc2 {
            content_by_lua_block {

            }
        }



        location /print {
            content_by_lua_block {
                
                -- print要手动 \n 换行
                ngx.print("asdxa", 11, "as \n")
                ngx.print("asdxa = ", 11, " = as \n")

                local ngx = require "ngx"

                ngx.print("121scas \n\nasc")

                local tab1 = '{"foo", "bar"}'
                ngx.print("tab1 = ", tab1)
            }
        }


        location /log {
            content_by_lua_block {

                -- ngx.log 将日志输出到 error.log 文件中

                ngx.log(ngx.INFO, "this is info log")
                local tt = require "test"

                ngx.print("tt.data = ", tt.data ,"\n")
                ngx.print("tt.get_str() = ", tt.get_str() ,"\n")

            }
        }

        location /say {
            content_by_lua_block {

                -- ngx.say是在ngx.print到基础上封装的函数，say自带\n输出
                local ngx = require "ngx"
                ngx.say("输出1")
                ngx.say("输出2")
                ngx.say("输出3")
            }
        }

        location /arg {
            content_by_lua_block {
                local ngx = require "ngx"
                ngx.say(ngx.arg)
                ngx.say(ngx.OK)
                ngx.say(ngx.HTTP_OK)
                ngx.say(ngx.HTTP_GET)
                ngx.say(ngx.null)
            }
        }

        location /fetch {
            content_by_lua_block {
                local fetch = require "fetch_domains"
                local fetch = require "fetch_domains"
                ngx.timer.at(0, fetch)
            }
        }
    }
}
