
# ngx.shared.dict的使用


location /t02/set {
    content_by_lua_block {

        -- 要使用t02_dict必须在nginx.conf里面声明，否则就是找不到了 
        -- lua_shared_dict t02_dict 10m;

        -- local value, flags = ngx.shared.DICT:get("t02_dict")
        -- if not flag then 
        --     local ok, err = ngx.say("t02_dict不存在")
        --     return ngx.exit(200)
        -- end
        -- value:set("t02_dict测试")

        -- ngx.shared.t02_dict 就是lua的一个table
        local dict = ngx.shared.t02_dict
        dict:set("key1", "hello", 30)  -- 值, 过期时间秒（可选）
        ngx.say("t02_dict 设置值成功！")

        local success, err, forcible = ngx.shared.t02_dict:set("keykey", "valuevaluevalue", 10)
        ngx.say("t02_dict['keykey'] 设置值成功！",success, err, forcible)

        return ngx.exit(200)
    }
}
location /t02/get {
    content_by_lua_block {

        local dict = ngx.shared.t02_dict
        ngx.say("startTime: ", dict:get("key1"))
        local value, flags = ngx.shared.t02_dict:get("keykey")
        ngx.say("keykey: ", value, flags)

        return ngx.exit(200)
    }
}

# 设置字典的某个值自增
location /t02/incr {
    content_by_lua_block {

        -- 先获取dict便与后续的多次操作
        local dict = ngx.shared.t02_dict

        local ok, err = ngx.say("获取：", dict:get("count"))
        -- 参数“count”表示在t02_dict这个表里面操作count这个key
        -- 参数1表示：自增1，2表示自增2
        -- 这个count不存在时的初始值是666
        local newval, err, forcible = dict:incr("count", 1, 666)
        -- newval自增后的新值
        -- incr操作是否发生错误
        -- forcible 内存不足的操作
        local ok, err = ngx.say("自增结果：", newval, ", err = ", err, ", forcible = ", forcible)
        local ok, err = ngx.say("自增之后获取：", dict:get("count"))

        return ngx.exit(200)
    }
}

# safe_add （原子加，不存在才能成功），通常用于获取锁
location /t02/safe_add {
    content_by_lua_block {
        local dict = ngx.shared["t02_dict"]

        -- 尝试获取锁
        -- safe_add(key, value, exptime?, flags?)
        local ok, err = dict:safe_add("lock", 1, 5)
        if ok then
            ngx.say("锁获取成功。", dict:get("lock"))
            -- do_something()
            dict:delete("lock")
        else
            ngx.say("锁获取失败！！！")
        end

    }
    
}

# delete 删除 key
location /t02/del {
    content_by_lua_block {
        local dict = ngx.shared["t02_dict"]

        local success, err, forcible = dict:set("del-key", "del-value")
        local ok, err = ngx.say("设置：", success)
        local ok, err = ngx.say("1获取成功：", dict:get("del-key"))
        dict:delete("del-key")
        local ok, err = ngx.say("2获取成功：", dict:get("del-key"))

    }
    
}

# ttl 查看某个key的过期时间
location /t02/ttl {
    content_by_lua_block {
        local dict = ngx.shared["t02_dict"]

        local success, err, forcible = dict:set("ttl-key", "ttl-value", 5)
        local ok, err = ngx.say("设置：", success)
        local ok, err = ngx.say("1获取成功：", dict:ttl("ttl-key"))
        ngx.sleep(1)
        local ok, err = ngx.say("2获取成功：", dict:ttl("ttl-key"))
        ngx.sleep(1)
        local ok, err = ngx.say("3获取成功：", dict:ttl("ttl-key"))
        ngx.sleep(1)
        local ok, err = ngx.say("4获取成功：", dict:ttl("ttl-key"))
        ngx.sleep(1)
        local ok, err = ngx.say("5获取成功：", dict:ttl("ttl-key"))
        ngx.sleep(1)
        local ok, err = ngx.say("5获取成功：", dict:ttl("ttl-key"))
    }
}

# 缓存某个接口5秒的数据
location /t02/cache-api {
    content_by_lua_block {
        local dict = ngx.shared["t02_dict"]

        -- 构造当前api的唯一key, api+param
        local apiKey = ngx.var["uri"]..":"..(ngx.var["args"] or "")
        local ok, err = ngx.say("当前apiKey = ", apiKey)

        -- 读缓存取结果
        local value, flags = dict:get(apiKey)
        if value then
            local ok, err = ngx.say("获取到缓存数据：", value)
            return ngx.exit(200)
        end

        -- 执行后端接口 require("resty.http")
        local valueFromBackend = "这个来自后端的数据"..ngx.now()
        -- 放入缓存
        local success, err, forcible = dict:set(apiKey, valueFromBackend, 5)
        ngx.say("数据放入缓存结果：", success)

        -- 返回结果
        ngx.say("数据来自后端：", valueFromBackend)
        return ngx.exit(200)
    }
}


# 获取某个字典的keys
location /t02/keys {
    content_by_lua_block {
        local dict = ngx.shared["t02_dict"]

        local keys = dict:get_keys()
        for k, v in pairs(keys) do
            ngx.say("k = ", key, ", v = ", v)
        end

        dict:set("key1", "value1")
        dict:set("key2", "value2")
        dict:set("key3", "value3")
        dict:set("key4", "value4")
        dict:set("key5", "value5")

        local ok, err = ngx.say("set之后")
        local keys = dict:get_keys()
        for k, v in pairs(keys) do
            ngx.say("k = ", key, ", v = ", v)
        end
        
    }
}

# 用 ngx.shared 实现定时更新服务端数据，（更新域名列表）
location /t02/domainf {
    content_by_lua_block {

        -- 下面这块代码一般是写在init_worker_by_lua_block里面的，这里只是为了做测试
        local dict = ngx.shared["t02_domains"]

        -- 刷新服务端的域名列表
        local function domain_refresh()
            ngx.log(ngx.INFO, "刷新域名列表"..ngx.now())

            if true then
                dict:set("list", "来自服务器的域名列表"..ngx.now())
                return
            end

            local http = require "resty.http"
            local hc = http.new()

            local res, err = h:request_uri("http://backend/domains")
            if not res then
                ngx.log(ngx.ERR, "fetch error: ", err)
                return
            end

            dict:set("list", res.body)
        end


        -- 每 60 秒执行一次
        local ok, err = ngx.timer.every(5, domain_refresh)
        if not ok then ngx.log(ngx.ERR, "failed to start timer: ", err) end

        return ngx.exit(200)
    }
}
location /t02/domaing {
    content_by_lua_block {
        local dict = ngx.shared["t02_domains"]
        local cjson = require "cjson.safe"
        local ok, err = ngx.say("最新的域名列表：", cjson.encode(dict:get("list")))
        return ngx.exit(200)
    }
}

# 限制某个用户的访问
location /t02/userapi {
    content_by_lua_block {
        local dict = ngx.shared.t02_domains
        local key = "ip:" .. ngx.var.remote_addr

        -- 自增计数，不存在则初始值=0
        local count, err = dict:incr(key, 1, 0)
        if not count then
            ngx.say("incr error: ", err)
            return
        end

        -- 设置 TTL（第一次访问时设置）
        if count == 1 then
            dict:expire(key, 1)   -- 1 秒窗口
        end

        if count > 10 then
            ngx.status = 429
            ngx.say("Too Many Requests")
            return
        end

        ngx.say("ok, count = ", count)
    }
}

# 接口连接数限制
# 例如某个接口并发最多只能 5 个。限制 DBQPS / 后端接口保护 / 压力控制
location /t02/api-con-limit {
    content_by_lua_block {
        local current, err = dict:incr("concurrent", 1, 0)
        if current > 5 then
            dict:incr("concurrent", -1)
            return ngx.exit(503)
        end

        -- 执行业务
        -- ...

        dict:incr("concurrent", -1)
    }
}



# 查看字典内存情况
location /t02/qqqq {
    content_by_lua_block {
        --[[
        local ip = ngx.var.remote_addr
local ua = ngx.var.http_user_agent or ""

-- 1. 白名单优先
if ngx.shared.whitelist:get(ip) then
    return
end

-- 2. 黑名单
if ngx.shared.blocklist:get(ip) then
    return ngx.exit(403)
end

-- 3. UA 黑名单
if ngx.shared.ua_block:get(ua) then
    return ngx.exit(403)
end

-- 4. CC 攻击防护
local key = "req:" .. ip
local dict = ngx.shared.rate
local count = dict:incr(key, 1, 0, 1)

if count > 20 then
    ngx.shared.blocklist:set(ip, true, 60)
    return ngx.exit(429)
end

        ]]
    }
}

# 查看字典内存情况
location /t02/status {
    content_by_lua_block {
        local dict = ngx.shared.t02_domains
        ngx.say("free: ", dict:free_space())
        ngx.say("capacity: ", dict:capacity())
    }
}

